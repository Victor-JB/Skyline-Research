% This script initializes workspace variables for the UAV Toolbox Reference
% Application.

% Set guidance type to Full Guidance
%<COMMENT>: This needs to be 0 for all fixed wing a/c
guidanceType = 1;

% Configure the drone as a Multicopter
isDroneMulticopter = 1;

% Do not use full photo realistic sim
isPhotoRealisticSim = 0;

% Low fidelity plant model 
plantModelFi = 1;

% No show for Lidar Point Cloud
showLidarPointCloud = 0;

% No show the Video Viewer
showVideoViewer = 0;

% Show the UAV Animation as it flies
%showUAVAnimation = 1; useless ahh that doesnt work

% Use heading in the guidance model
useHeading = 1;

%Takeoff after 0 S
startFlightTime = 0;

% Do not use QGroundControl
useQGC = 0;

% No pacing
load_system('uavPackageDelivery');
set_param('uavPackageDelivery','EnablePacing', 'of');

% Simulation Stop Time
simTime = 100;

% Done

numRuns = 100;  % Number of Monte Carlo simulations
errors = zeros(numRuns,1);  % Store final distance error (Euclidean)

for i = 1:numRuns
    % ==== Random Inputs Per Run ====
    
    % Random mass (3â€“5 kg scaled to model)
    input_mass = 3 + (5 - 3) * rand(); 
    mass_param = Simulink.Parameter((input_mass-3)/100 + 0.06);
    mass_param.CoderInfo.StorageClass = 'ExportedGlobal';
    assignin('base', 'mass_param', mass_param);

    % Random base wind
    baseWindRange = [3; 3; 1];
    baseWind = baseWindRange .* (2 * rand(3,1) - 1);

    % Random gusts
    T = 50;
    dt = 0.1;
    t = 0:dt:T;

    gustX = zeros(size(t));
    gustY = zeros(size(t));
    gustZ = zeros(size(t));
    for j = 1:round(5/dt):length(t)
        gustX(j:end) = gustX(j:end) + (rand()-0.5)*2;
        gustY(j:end) = gustY(j:end) + (rand()-0.5)*2;
        gustZ(j:end) = gustZ(j:end) + (rand()-0.5)*0.5;
    end

    windTotal = [baseWind(1) + gustX;
                 baseWind(2) + gustY;
                 baseWind(3) + gustZ]';

    wind_param = timeseries(windTotal, t');
    assignin('base', 'wind_param', wind_param);

    % GPS Drift
    gpsDriftX = cumsum(randn(length(t), 1) * 0.01);
    gpsDriftY = cumsum(randn(length(t), 1) * 0.01);
    gps_drift_signal = timeseries([gpsDriftX, gpsDriftY], t);
    assignin('base', 'gps_drift_signal', gps_drift_signal);

    % IMU Drift
    gyroDrift = cumsum(randn(length(t), 3) * deg2rad(0.01));
    gyro_drift_signal = timeseries(gyroDrift, t);
    assignin('base', 'gyro_drift_signal', gyro_drift_signal);

    % Barometric Drift
    baroDriftZ = cumsum(randn(length(t), 1) * 0.01);
    baro_drift_signal = timeseries(baroDriftZ, t);
    assignin('base', 'baro_drift_signal', baro_drift_signal);

    % Motor delay
    motor_delay_time = 0.015 + 0.005*randn;
    assignin('base', 'motor_delay_time', motor_delay_time);

    % ==== Run Simulation ====
    simOut = sim('uavPackageDelivery');

    % ==== Log Result ====
    uavState = simOut.logsout.get('UAVState').Values;
    pos = uavState.pos_vel;

    finalXYZ = [pos.x.Data(end), pos.y.Data(end), pos.z.Data(end)];
    goalXYZ = [-120, -10, 0];
    errorVec = finalXYZ - goalXYZ;
    errors(i) = norm(errorVec);
end

% ==== Plot Error Distribution ====
figure;
histogram(errors, 'Normalization', 'pdf', 'BinWidth', 0.2);
xlabel('Landing Error (meters)');
ylabel('Probability Density');
title(sprintf('Monte Carlo Error Distribution (%d runs)', numRuns));
grid on;
